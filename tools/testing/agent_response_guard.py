#!/usr/bin/env python3
"""Guard: validate agent responses contain Novice and Technical sections and mark autogenerated assumptions.

This script scans one or more text files (for example, AI assistant reply drafts or session transcripts)
and enforces the repository policy that every agent-produced artifact must:

  - Include both a "Novice Summary" (plain-language) and a "Technical Specification" (developer-facing).
  - Avoid unresolved placeholders like TBD/TODO/SPEC-XXXX/DEC-XXXX unless they are explicitly
    accompanied by an AUTOGENERATED ASSUMPTION marker.
  - Ensure any AUTOGENERATED ASSUMPTION includes a short rationale and a confidence level.

Exit status:
  0  - all files pass the checks
  1  - one or more checks failed (errors printed to stderr)

Usage:
  python -m agent_response_guard --files path/to/agent_reply.md ...
  python -m agent_response_guard --root ./repo --files path/relative1.md path/relative2.md
"""

from __future__ import annotations

import argparse
import re
import sys
from collections.abc import Iterable
from pathlib import Path

NOVICE_RE = re.compile(r"(?im)^\s*(?:#+\s*)?(Novice Summary|Novice:)\b")
TECH_RE = re.compile(r"(?im)^\s*(?:#+\s*)?(Technical Specification|Technical Spec|Technical:)\b")

# Placeholder tokens that must not remain unresolved unless accompanied by an AUTOGENERATED marker
PLACEHOLDER_RE = re.compile(
    r"\b(TBD|TODO|PLACEHOLDER|<placeholder>|__PLACEHOLDER__|SPEC-XXXX|DEC-XXXX)\b",
    flags=re.IGNORECASE,
)

# Accepted forms of autogenerated markers
AUTOGEN_MARKER_RE = re.compile(
    r"(?i)\b(?:AUTOGENERATED ASSUMPTION|AUTOGENERATED|AUTO-GENERATED|AUTO GENERATED|AUTO-GEN)\b"
)

# We expect an autogenerated assumption to include a short rationale and a confidence indicator.
CONFIDENCE_RE = re.compile(r"(?i)\b(confidence|confidence:|confidence level|confident):?")
RATIONALE_RE = re.compile(r"(?i)\b(rationale|reason|because|why|justification):?")


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--files",
        nargs="+",
        help="Files to validate (paths relative to --root or absolute).",
    )
    parser.add_argument(
        "--root",
        type=Path,
        default=Path.cwd(),
        help="Repository root used to resolve relative file paths.",
    )
    return parser.parse_args()


def normalise(paths: Iterable[str]) -> list[str]:
    normalised: list[str] = []
    for raw in paths or []:
        if raw is None:
            continue
        p = raw.strip()
        if not p:
            continue
        normalised.append(p.replace("\\", "/"))
    return normalised


def read_text(path: Path) -> str:
    try:
        return path.read_text(encoding="utf-8")
    except Exception as exc:  # pragma: no cover - defensive
        raise RuntimeError(f"could not read {path}: {exc}") from exc


def find_lines_with_indices(text: str) -> list[str]:
    return text.splitlines()


def locate_marker_near(lines: list[str], idx: int, marker_re: re.Pattern, window: int = 3) -> bool:
    """Check for a marker within a window of lines around index idx (0-based)."""
    start = max(0, idx - window)
    end = min(len(lines), idx + window + 1)
    for i in range(start, end):
        if marker_re.search(lines[i]):
            return True
    return False


def validate_file(path: Path) -> list[str]:
    errors: list[str] = []
    if not path.exists():
        errors.append(f"agent-response guard: file not found: {path}")
        return errors

    text = read_text(path)
    lines = find_lines_with_indices(text)

    # 1) Ensure both Novice and Technical sections exist
    if not NOVICE_RE.search(text):
        errors.append(f"{path}: missing 'Novice Summary' section (required).")
    if not TECH_RE.search(text):
        errors.append(f"{path}: missing 'Technical Specification' section (required).")

    # 2) Find unresolved placeholders and ensure they are accompanied by an AUTOGENERATED marker.
    for i, line in enumerate(lines):
        for match in PLACEHOLDER_RE.finditer(line):
            token = match.group(1)
            # Check for an autogen marker nearby (same line or within +/- 2 lines)
            has_autogen = locate_marker_near(lines, i, AUTOGEN_MARKER_RE, window=2)
            if not has_autogen:
                errors.append(
                    f"{path}: unresolved placeholder '{token}' on line {i + 1} without an AUTOGENERATED marker."
                )
            else:
                # When there's an autogen marker, verify rationale and confidence also present nearby
                has_rationale = locate_marker_near(lines, i, RATIONALE_RE, window=4)
                has_conf = locate_marker_near(lines, i, CONFIDENCE_RE, window=4)
                if not has_rationale:
                    errors.append(
                        f"{path}: AUTOGENERATED assumption near line {i + 1} missing a short rationale (look for 'rationale:'/'reason:' nearby)."
                    )
                if not has_conf:
                    errors.append(
                        f"{path}: AUTOGENERATED assumption near line {i + 1} missing a confidence indicator (e.g. 'confidence: High')."
                    )

    # 3) Extra check: any AUTOGENERATED markers should appear in context of either Novice or Technical sections.
    #    We warn/error if an AUTOGENERATED marker exists but the file lacks both sections (caught above)
    #    or if the marker is present but not explained.
    for i, line in enumerate(lines):
        if AUTOGEN_MARKER_RE.search(line):
            # Ensure marker is followed or preceded by a short explanatory phrase including 'rationale' or 'confidence'
            has_rationale = locate_marker_near(lines, i, RATIONALE_RE, window=4)
            has_conf = locate_marker_near(lines, i, CONFIDENCE_RE, window=4)
            if not (has_rationale and has_conf):
                errors.append(
                    f"{path}: AUTOGENERATED marker on line {i + 1} must include both a short rationale and a confidence level within a few lines."
                )

    return errors


def main() -> int:
    args = parse_args()
    files = normalise(args.files or [])
    if not files:
        print("agent-response guard: no files provided; nothing to check.", file=sys.stderr)
        return 0

    errors: list[str] = []
    for raw in files:
        p = Path(raw)
        if not p.is_absolute():
            p = args.root / p
        p = p.resolve()
        try:
            result = validate_file(p)
        except Exception as exc:  # pragma: no cover - defensive
            errors.append(f"{p}: unexpected error while validating: {exc}")
            continue
        errors.extend(result)

    if errors:
        for err in errors:
            print(err, file=sys.stderr)
        return 1
    return 0


if __name__ == "__main__":  # pragma: no cover
    sys.exit(main())
